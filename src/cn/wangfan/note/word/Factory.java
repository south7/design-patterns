package cn.wangfan.note.word;

/**
 * 工厂模式
 * @author wangfan
 *
 */
public class Factory {
/**
 * 设计模式
 * 作用:为了重用代码，解耦，让代码更容易被他人理解，保证代码可靠性
 * 工厂模式:简单工厂、工厂方法、抽象工厂
 * 简单工厂：这个模式本身简单，而且使用在业务较简单的情况下
 * 关键点：
 *   工厂类角色：这是本模式的核心，会有一定的商业逻辑和判断逻辑，在java中它往往由一个具体类实现
 *   抽象产品角色：它一般是具体产品继承的父类或者实现的接口，在java中由接口或者实现类来实现
 *   具体产品角色：工厂类所创建的对象就是此角色的实例，在java中由一个具体类实现
 * 缺点：扩展性差，违反开闭原则  
 * 问题：开闭原则分析简单工厂模式
 * 开闭原则：对扩展开放，对修改封闭。一个软件应该通过扩展来实现变化，而不是修改已有的代码来实现变化的
 * 
 * 工厂方法：定义一个创建对象的工厂接口，让子类决定实例化哪一个类，将实际工作交给子类
 * 如果工厂的产品全部属于同一个登记结构，则属于工厂方法模式。
 * 关键点：
 *   抽象工厂角色：这是工厂方法模式的核心，是具体工厂角色必须实现的接口或者必须继承的类。在java中它由抽象类或者接口来实现
 *   具体工厂角色:它含有和具体业务逻辑有关的代码，创建具体对应产品的对象。在java中由具体的类实现。
 *   抽象产品角色：它是具体产品继承的父类或者实现的接口。在java中一般由抽象类或者接口实现。
 *   具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类实现。
 * 问题:工厂方法模式足以应付我们可能遇到的大部分业务需求，但是当产品种类非常多时会怎么样呢 
 * 分析优缺点：
 *   优点:更符合开闭原则：新增一种产品时，只需要增加相应的具体产品类和相应的工厂之类即可。
 *       符合单一职责原则:每个具体工厂类只负责创建对应的产品。
 *   缺点：在增加一个新产品的时候，需要增加一个产品类和一个具体的子工厂，给系统增加负担的同时，每个工厂生产一种产品，太过单一
 *
 *抽象工厂：给客户端提供一个接口，可以创建多个产品族中的产品对象
 *如果工厂的产品来自多个等级结构，则属于抽象工厂模式
 *
 *总结：
 *  无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，它们都属于工厂模式，在行为和特点上是极为相似的，最终目的是解耦
 *  使用工厂模式时，只需要关心降低耦合度的目的是否达到了
 */
}
